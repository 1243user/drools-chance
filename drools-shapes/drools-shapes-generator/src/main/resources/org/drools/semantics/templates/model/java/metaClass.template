
@declare{'metaClassTemplate'}

package @{ package };

public class @{ typeName }_<T extends @{package}.@{ typeName }> extends @if{ "Thing".equals( supertypeName ) } org.drools.core.metadata.MetadataContainer<T> @else{} @{ supertypePackage }.@{ supertypeName }_<T> @end{} {

        public @{ typeName }_( T x ) {
            super( x );
            metaClassInfo = @{ typeName }_Meta.getInstance();
        }

        @code{ int q = 0; }
        @foreach{ prop : propertyNames }
            @if{ ! inheritedFlags[ q ] }
            public static final org.drools.core.metadata.MetaProperty<@{package}.@{typeName},@{javaTypeNames[ q ]}> @{ prop } = @{ typeName }_Meta.@{ prop };
            @end{}
            @code{ q++; }
        @end{ '\n' }

        public static <X extends @{package}.@{ typeName }> @{ typeName }_NewInstance<X> new@{ typeName }( Object id ) {
            return @{ typeName }_Meta.getInstance().newInstance( id );
        }

        public static <X, K extends @{package}.@{ typeName }> @{ typeName }_Don<X,K> don@{ typeName }( X core ) {
            return new @{ typeName }_Don<X,K>( core );
        }

        public static @{typeName}_Modify<? extends @{ typeName }> modify( @{ typeName } x ) {
            return new @{ typeName }_Modify<@{ typeName }>( x );
        }

        public @{typeName}_Modify<T> modify() {
            return new @{typeName}_Modify<T>( getTarget() );
        }

        public static class @{ typeName }_NewInstance<T extends @{package}.@{ typeName } > extends @if{ "Thing".equals( supertypeName ) } org.drools.core.metadata.NewInstanceLiteral<T> @else{} @{ supertypePackage }.@{ supertypeName }_.@{ supertypeName }_NewInstance<T> @end{} {

            public @{ typeName }_NewInstance( Object id ) {
                super( java.net.URI.create( id.toString() ) );
            }

            public boolean isInterface() {
                return true;
            }

            protected Object construct() {
                if ( getInstantiatorFactory() != null ) {
                    return getInstantiatorFactory().instantiate( @{ typeName }.class, getId() );
                }
                @{package}.@{ typeName }Impl x = new @{package}.@{ typeName }Impl();
                x.setDyEntryId( getId().toString() );
                return x;
            }

            @code{ int s = 0; }
            @foreach{ prop : propertyNames }
                public @{ typeName }_NewInstance<T> @{ prop }( @{javaTypeNames[ s ]} value ) {
                    @if{ ! inheritedFlags[ s ] }
                        getSetter().@{ prop }( value );
                    @else{}
                        super().@{ prop }( value );
                    @end{}
                        return this;
                }
                @code{ s++; }
            @end{ '\n' }

            protected @{ typeName }_Modify<T> getSetter() {
                if ( setter == null ) {
                    setter = new @{ typeName }_Modify( null );
                }
                return ( @{ typeName }_Modify<T>) setter;
            }

        @Override
        public Class<T> getInstanceClass() {
            return @{ typeName }_Meta.getInstance().getTargetClass();
        }

    }

        public static class @{typeName}_Modify<T extends @{typeName}> extends @if{ "Thing".equals( supertypeName ) } org.drools.core.metadata.ModifyLiteral<T> @else{} @{ supertypePackage }.@{ supertypeName }_.@{ supertypeName }_Modify<T> @end{} {
            public @{ typeName }_Modify( T x ) {
                super( x );
            }

            @Override
            protected org.drools.core.metadata.MetaClass<T> getMetaClassInfo() {
                return @{ typeName }_Meta.getInstance();
            }

            public Class getModificationClass() {
                return @{ package }.@{ typeName }.class;
            }

            @code{ int z = 0; }
            @foreach{ prop : propertyNames }
                public @{typeName}_Modify @{prop}(  @{javaTypeNames[z]} newVal ) {
                    @if{ ! inheritedFlags[z] }
                        addTask( @{prop}, newVal );
                    @else{}
                        super.@{prop}( newVal );
                    @end{}
                    return this;
                }
                @code{ z++; }
            @end{ '\n' }
        }


    protected static class @{ typeName }_Meta<T extends @{ package }.@{ typeName }> extends org.drools.core.metadata.ClassLiteral<T> {

        private static @{ typeName }_Meta instance;

        public static @{ typeName }_Meta getInstance() {
            if ( instance == null ) {
                instance = new @{ typeName }_Meta( new org.drools.core.metadata.MetaProperty[] {
                        @code{ int t = 0; } @foreach{ prop : propertyNames } @if{ ! inheritedFlags[t] } @{ prop }, @end{} @code{ t++; } @end{}
                } );
            }
            return instance;
        }

        @code{ int k = 0; }
        @foreach{ prop : propertyNames }
            @if{ ! inheritedFlags[k] }
            public static final org.drools.core.metadata.MetaProperty<@{package}.@{typeName},@{javaTypeNames[k]}> @{prop} =
                    new org.drools.core.metadata.PropertyLiteral<@{package}.@{typeName},@{javaTypeNames[k]}>( @{k}, "@{prop}", java.net.URI.create( "@{ propertyIris[k] }" ) ) {
                public @{javaTypeNames[k]} get( @{package}.@{typeName} o ) { return o.@{ getter( prop, map( typeNames[k], true ), simpleFlags[k] ? 1 : null ) }(); }
                public void set( @{package}.@{typeName} o, @{javaTypeNames[k]} value ) { o.@{ setter( prop ) }( value ); }
            };
            @end{}
            @code{ k++; }
        @end{ '\n' }

        protected @{ typeName }_Meta( org.drools.core.metadata.MetaProperty<T, ?>[] propertyLiterals ) {
            super( propertyLiterals );
        }

        @Override
        protected void cachePropertyNames() {
            propertyNames = org.drools.core.util.ClassUtils.getSettableProperties( @{ package }.@{ typeName }.class );
        }

        @Override
        public java.net.URI getUri() {
            if ( key == null ) {
                key = java.net.URI.create( "@{ typeIri }" );
            }
            return key;
        }

        public @{ typeName }_NewInstance<T> newInstance( Object id ) {
            return new @{ typeName }_NewInstance<T>( id );
        }

        @Override
        public Class<T> getTargetClass() {
            return (Class<T>) @{ package }.@{ typeName }.class;
        }
    }

    public static class @{typeName}_Don<K, T extends @{typeName}> extends @if{ "Thing".equals( supertypeName ) } org.drools.core.metadata.DonLiteral<K,T> @else{} @{ supertypePackage }.@{ supertypeName }_.@{ supertypeName }_Don<K,T> @end{} {
        public @{ typeName }_Don( K target ) {
            super( target );
        }

        @Override
        protected org.drools.core.metadata.MetaClass<T> getMetaClassInfo() {
            return @{ typeName }_Meta.getInstance();
        }

        @Override
        public Class<T> getTrait() {
            return @{ typeName }_Meta.getInstance().getTargetClass();
        }

        @Override
        public @{ typeName }_Don<K,T> setTraitFactory( org.drools.core.factmodel.traits.AbstractTraitFactory factory ) {
            super.setTraitFactory( factory );
            return this;
        }

            @code{ int w = 0; }
            @foreach{ prop : propertyNames }
                public @{ typeName }_Don<K,T> @{ prop }( @{javaTypeNames[ w ]} value ) {
                    @if{ ! inheritedFlags[ w ] }
                        getSetter().@{ prop }( value );
                    @else{}
                        super().@{ prop }( value );
                    @end{}
                        return this;
                }
                @code{ w++; }
            @end{ '\n' }

            protected @{ typeName }_Modify<T> getSetter() {
                if ( setter == null ) {
                    setter = new @{ typeName }_Modify( null );
                }
                return ( @{ typeName }_Modify<T>) setter;
            }
    }


}
@end{}

@includeNamed{'metaClassTemplate'}